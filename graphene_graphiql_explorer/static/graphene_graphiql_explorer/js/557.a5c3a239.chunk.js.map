{"version":3,"file":"static/js/557.a5c3a239.chunk.js","mappings":"iQAAIA,EAAYC,OAAOC,eACnBC,EAAS,SAACC,EAAQC,GAAK,OAAKL,EAAUI,EAAQ,OAAQ,CAAEC,MAAAA,EAAOC,cAAc,GAAO,EAClFC,EAAe,WACnB,WAAYC,GAAY,2BACtBC,KAAKC,gBAAkB,kBAAM,EAAKC,MAAM,EACxCF,KAAKG,mBAAqB,kBAAM,EAAKC,IAAI,EACzCJ,KAAKK,IAAM,kBAAM,EAAKC,YAAYC,SAAW,EAAKH,IAAI,EACtDJ,KAAKQ,IAAM,kBAAoB,IAAd,EAAKJ,IAAU,EAChCJ,KAAKS,KAAO,WACV,OAAO,EAAKH,YAAYI,OAAO,EAAKN,MAAQ,EAAKE,YAAYI,OAAO,EAAKN,MAAQ,IACnF,EACAJ,KAAKW,KAAO,WACV,IAAMC,EAAO,EAAKN,YAAYI,OAAO,EAAKN,MAE1C,OADA,EAAKA,OACEQ,CACT,EACAZ,KAAKa,IAAM,SAACC,GAEV,GADkB,EAAKC,mBAAmBD,GAIxC,OAFA,EAAKZ,OAAS,EAAKE,KACnB,EAAKA,OACE,EAAKE,YAAYI,OAAO,EAAKN,KAAO,EAG/C,EACAJ,KAAKgB,SAAW,SAACC,GACf,IAAIC,EAAY,EAAKH,mBAAmBE,GACpCE,GAAS,EAKb,IAJID,IACFC,EAASD,EACT,EAAKhB,OAAS,EAAKE,MAEdc,GACL,EAAKd,OACLc,EAAY,EAAKH,mBAAmBE,GACpCE,GAAS,EAEX,OAAOA,CACT,EACAnB,KAAKoB,SAAW,kBAAM,EAAKJ,SAAS,aAAa,EACjDhB,KAAKqB,UAAY,WACf,EAAKjB,KAAO,EAAKE,YAAYC,MAC/B,EACAP,KAAKsB,OAAS,SAACC,GACb,EAAKnB,KAAOmB,CACd,EACAvB,KAAKiB,MAAQ,SAACH,GAA8C,IAArCU,IAAU,UAAH,+CACxBC,EAAQ,KACRR,EAAQ,KACW,kBAAZH,GAETG,EADc,IAAIS,OAAOZ,EAJqB,UAAH,8CAIE,IAAM,KACrCa,KAAK,EAAKrB,YAAYsB,OAAO,EAAKxB,KAAMU,EAAQP,SAC9DkB,EAAQX,GACCA,aAAmBY,SAE5BD,EAAkB,QADlBR,EAAQ,EAAKX,YAAYuB,MAAM,EAAKzB,MAAMa,MAAMH,UACZ,IAAVG,OAAmB,EAASA,EAAM,IAE9D,QAAa,MAATA,KACqB,kBAAZH,GAAwBG,aAAiBa,OAAS,EAAKxB,YAAYyB,WAAWd,EAAM,GAAI,EAAKb,UAClGoB,IACF,EAAKtB,OAAS,EAAKE,KACfqB,GAASA,EAAMlB,SACjB,EAAKH,MAAQqB,EAAMlB,SAGhBU,EAIb,EACAjB,KAAKgC,OAAS,SAACC,GACb,EAAK7B,MAAQ6B,CACf,EACAjC,KAAKkC,OAAS,kBAAM,EAAK9B,IAAI,EAC7BJ,KAAKmC,YAAc,WACjB,IAAMlB,EAAQ,EAAKX,YAAYW,MAAM,OACjCmB,EAAS,EACb,GAAInB,GAA0B,IAAjBA,EAAMV,OAGjB,IAFA,IAAM8B,EAAcpB,EAAM,GACtBqB,EAAM,EACHD,EAAY9B,OAAS+B,GACU,IAAhCD,EAAYE,WAAWD,GACzBF,GAAU,EAEVA,IAEFE,IAGJ,OAAOF,CACT,EACApC,KAAKwC,QAAU,kBAAM,EAAKlC,YAAYuB,MAAM,EAAK3B,OAAQ,EAAKE,KAAK,EACnEJ,KAAKE,OAAS,EACdF,KAAKI,KAAO,EACZJ,KAAKM,YAAcP,CACrB,CAUC,OAVA,0CACD,SAAmBe,GACjB,IAAM2B,EAAYzC,KAAKM,YAAYI,OAAOV,KAAKI,MAO/C,MALuB,kBAAZU,EACG2B,IAAc3B,EAEdA,aAAmBY,OAASZ,EAAQa,KAAKc,GAAa3B,EAAQ2B,EAG9E,KAAC,EAvGkB,GAyGrB/C,EAAOI,EAAiB,mBAAmB,IACrC4C,EAAK,WACT,WAAYC,EAAOC,GAAK,2BACtB5C,KAAK6C,iBAAmB,SAACtB,GACvB,OAAI,EAAKoB,MAAMG,OAASvB,EAASuB,KACxB,EAAKH,MAAMF,WAAalB,EAASkB,UAC/B,EAAKG,IAAIE,OAASvB,EAASuB,KAC7B,EAAKF,IAAIH,WAAalB,EAASkB,UAE/B,EAAKE,MAAMG,MAAQvB,EAASuB,MAAQ,EAAKF,IAAIE,MAAQvB,EAASuB,IAEzE,EACA9C,KAAK2C,MAAQA,EACb3C,KAAK4C,IAAMA,CACb,CAMC,OANA,gCACD,SAASE,EAAML,GACbzC,KAAK2C,MAAQ,IAAII,EAASD,EAAML,EAClC,GAAC,oBACD,SAAOK,EAAML,GACXzC,KAAK4C,IAAM,IAAIG,EAASD,EAAML,EAChC,KAAC,EAnBQ,GAqBX/C,EAAOgD,EAAO,SAAS,IACjBK,EAAQ,WACZ,WAAYD,EAAML,GAAW,2BAC3BzC,KAAKgD,kBAAoB,SAACzB,GAAQ,OAAK,EAAKuB,KAAOvB,EAASuB,MAAQ,EAAKA,OAASvB,EAASuB,MAAQ,EAAKL,WAAalB,EAASkB,SAAS,EACvIzC,KAAK8C,KAAOA,EACZ9C,KAAKyC,UAAYA,CACnB,CAMC,OANA,+BACD,SAAQK,GACN9C,KAAK8C,KAAOA,CACd,GAAC,0BACD,SAAaL,GACXzC,KAAKyC,UAAYA,CACnB,KAAC,EAXW,GAad/C,EAAOqD,EAAU,W,sLC/IbxD,G,gBAAYC,OAAOC,gBACnBC,EAAS,SAACC,EAAQC,GAAK,OAAKL,EAAUI,EAAQ,OAAQ,CAAEC,MAAAA,EAAOC,cAAc,GAAO,EAUxF,SAASoD,EAAmBC,GAC1B,IAAIC,EAYJ,OAXAC,EAAaF,GAAY,SAACG,GACxB,OAAQA,EAAMC,MACZ,IAAK,QACL,IAAK,aACL,IAAK,WACL,IAAK,eACL,IAAK,qBACHH,EAAkBE,EAGxB,IACOF,CACT,CAEA,SAASI,EAAYC,EAAQC,EAAMC,GACjC,OAAIA,IAAcC,EAAAA,EAAAA,MAA2BH,EAAOI,iBAAmBH,EAC9DE,EAAAA,EAELD,IAAcG,EAAAA,EAAAA,MAAyBL,EAAOI,iBAAmBH,EAC5DI,EAAAA,EAELH,IAAcI,EAAAA,EAAAA,OAA6BC,EAAAA,EAAAA,IAAgBN,GACtDK,EAAAA,EAEL,cAAeL,EACVA,EAAKO,YAAYN,GAEnB,IACT,CAEA,SAASN,EAAaa,EAAOC,GAG3B,IAFA,IAAMC,EAAoB,GACtBd,EAAQY,EACK,OAAVZ,QAA4B,IAAVA,OAAmB,EAASA,EAAMC,MACzDa,EAAkBC,KAAKf,GACvBA,EAAQA,EAAMgB,UAEhB,IAAK,IAAIC,EAAIH,EAAkB5D,OAAS,EAAG+D,GAAK,EAAGA,IACjDJ,EAAGC,EAAkBG,GAEzB,CAEA,SAASC,EAAaC,GAIpB,IAHA,IAAMC,EAAOjF,OAAOiF,KAAKD,GACnBE,EAAMD,EAAKlE,OACXoE,EAAS,IAAI7C,MAAM4C,GAChBJ,EAAI,EAAGA,EAAII,IAAOJ,EACzBK,EAAOL,GAAKE,EAAOC,EAAKH,IAE1B,OAAOK,CACT,CAEA,SAASC,EAASnD,EAAOoD,GACvB,OAAOC,EAAkBD,EAAME,EAActD,EAAMuD,QACrD,CAEA,SAASF,EAAkBD,EAAMI,GAC/B,OAAKA,EAOEC,EAAeA,EAJFL,EAAKM,KAAI,SAACC,GAAK,MAAM,CACvCC,UAAWC,EAAaP,EAAcK,EAAMG,OAAQN,GACpDG,MAAAA,EACD,KACiD,SAACI,GAAI,OAAKA,EAAKH,WAAa,CAAC,KAAG,SAACG,GAAI,OAAMA,EAAKJ,MAAMK,YAAY,IAAEC,MAAK,SAACC,EAAGC,GAAC,OAAMD,EAAEP,MAAMK,aAAe,EAAI,IAAMG,EAAER,MAAMK,aAAe,EAAI,IAAME,EAAEN,UAAYO,EAAEP,WAAaM,EAAEP,MAAMG,MAAMhF,OAASqF,EAAER,MAAMG,MAAMhF,MAAM,IAAE4E,KAAI,SAACK,GAAI,OAAKA,EAAKJ,KAAK,IANjSF,EAAeL,GAAM,SAACO,GAAK,OAAMA,EAAMK,YAAY,GAO9D,CAEA,SAASP,EAAeW,EAAOC,GAC7B,IAAMC,EAAWF,EAAMG,OAAOF,GAC9B,OAA2B,IAApBC,EAASxF,OAAesF,EAAQE,CACzC,CAEA,SAAShB,EAAcE,GACrB,OAAOA,EAAKgB,cAAcC,QAAQ,MAAO,GAC3C,CAEA,SAASZ,EAAaa,EAAYlB,GAChC,IAAII,EAAYe,EAAgBnB,EAAMkB,GAKtC,OAJIA,EAAW5F,OAAS0E,EAAK1E,SAC3B8E,GAAac,EAAW5F,OAAS0E,EAAK1E,OAAS,EAC/C8E,GAA0C,IAA7Bc,EAAWE,QAAQpB,GAAc,EAAI,IAE7CI,CACT,CAEA,SAASe,EAAgBT,EAAGC,GAC1B,IAAItB,EACAgC,EACEC,EAAI,GACJC,EAAUb,EAAEpF,OACZkG,EAAUb,EAAErF,OAClB,IAAK+D,EAAI,EAAGA,GAAKkC,EAASlC,IACxBiC,EAAEjC,GAAK,CAACA,GAEV,IAAKgC,EAAI,EAAGA,GAAKG,EAASH,IACxBC,EAAE,GAAGD,GAAKA,EAEZ,IAAKhC,EAAI,EAAGA,GAAKkC,EAASlC,IACxB,IAAKgC,EAAI,EAAGA,GAAKG,EAASH,IAAK,CAC7B,IAAMI,EAAOf,EAAErB,EAAI,KAAOsB,EAAEU,EAAI,GAAK,EAAI,EACzCC,EAAEjC,GAAGgC,GAAKK,KAAKC,IAAIL,EAAEjC,EAAI,GAAGgC,GAAK,EAAGC,EAAEjC,GAAGgC,EAAI,GAAK,EAAGC,EAAEjC,EAAI,GAAGgC,EAAI,GAAKI,GACnEpC,EAAI,GAAKgC,EAAI,GAAKX,EAAErB,EAAI,KAAOsB,EAAEU,EAAI,IAAMX,EAAErB,EAAI,KAAOsB,EAAEU,EAAI,KAChEC,EAAEjC,GAAGgC,GAAKK,KAAKC,IAAIL,EAAEjC,GAAGgC,GAAIC,EAAEjC,EAAI,GAAGgC,EAAI,GAAKI,GAElD,CAEF,OAAOH,EAAEC,GAASC,EACpB,CA9FA/G,EAAOuD,EAAoB,sBAgB3BvD,EAAO6D,EAAa,eAYpB7D,EAAO0D,EAAc,gBAUrB1D,EAAO6E,EAAc,gBAIrB7E,EAAOkF,EAAU,YAWjBlF,EAAOoF,EAAmB,qBAK1BpF,EAAOwF,EAAgB,kBAIvBxF,EAAOqF,EAAe,iBAStBrF,EAAO4F,EAAc,gBAwBrB5F,EAAO0G,EAAiB,mBACxB,IAAMS,EAAoB,CACxBC,QAAS,+BACTC,MAAO,eAEHC,EAAsCtH,GAAO,SAACuH,GAClD,IAAMC,EAAoB,GAC1B,GAAID,EACF,KACEE,EAAAA,EAAAA,KAAMC,EAAAA,EAAAA,IAAMH,GAAK,CACfI,mBAAkB,SAACC,GACjBJ,EAAkB9C,KAAKkD,EACzB,GAEJ,CAAE,MAAOC,GACP,MAAO,EACT,CAEF,OAAOL,CACT,GAAG,uBACH,SAASM,EAA2BhE,EAAQiE,EAAWC,EAAQC,EAAcC,EAAcC,GACzF,IAAIN,EACEO,EAAOtI,OAAOuI,OAAOvI,OAAOuI,OAAO,CAAC,EAAGF,GAAU,CAAErE,OAAAA,IACnD/B,EAAQkG,GAAgBK,EAAmBP,EAAWC,GACtDrE,EAA6B,YAArB5B,EAAM4B,MAAMC,KAAqB7B,EAAM4B,MAAMgB,UAAY5C,EAAM4B,MAC7E,IAAKA,EACH,MAAO,GAET,IAAMC,EAAOD,EAAMC,KACb2E,EAAO5E,EAAM4E,KACbC,EAAWC,EAAY3E,EAAQ/B,EAAM4B,OAC3C,GAAIC,IAAS8E,EAAAA,EAAAA,SACX,OAAOxD,EAASnD,EAAO,CACrB,CAAE8D,MAAO,QAASjC,KAAM+E,EAAAA,EAAAA,UACxB,CAAE9C,MAAO,WAAYjC,KAAM+E,EAAAA,EAAAA,UAC3B,CAAE9C,MAAO,eAAgBjC,KAAM+E,EAAAA,EAAAA,UAC/B,CAAE9C,MAAO,WAAYjC,KAAM+E,EAAAA,EAAAA,UAC3B,CAAE9C,MAAO,IAAKjC,KAAM+E,EAAAA,EAAAA,eAGxB,GAAI/E,IAAS8E,EAAAA,EAAAA,YAAwB9E,IAAS8E,EAAAA,EAAAA,aAAoD,QAA1Bb,EAAKlE,EAAMgB,iBAA8B,IAAPkD,OAAgB,EAASA,EAAGjE,QAAU8E,EAAAA,EAAAA,WAC9I,OAAOE,EAA4B7G,EAAO4B,EAAOG,EAAQiE,EAAWS,GAEtE,GAAI5E,IAAS8E,EAAAA,EAAAA,eAA2B9E,IAAS8E,EAAAA,EAAAA,OAAmB9E,IAAS8E,EAAAA,EAAAA,cAC3E,OAAOG,EAA4B9G,EAAOyG,EAAUJ,GAEtD,GAAIxE,IAAS8E,EAAAA,EAAAA,WAAuB9E,IAAS8E,EAAAA,EAAAA,UAA+B,IAATH,EAAY,CAC7E,IAAMO,EAAUN,EAASM,QACzB,GAAIA,EACF,OAAO5D,EAASnD,EAAO+G,EAAQrD,KAAI,SAACsD,GAClC,IAAIC,EACJ,MAAO,CACLnD,MAAOkD,EAAOE,KACdC,WAAYH,EAAOE,KAAO,KAC1B7B,QAASD,EACTgC,OAAQC,OAAOL,EAAOhF,MACtBsF,cAA8C,QAA9BL,EAAMD,EAAOO,mBAAiC,IAARN,EAAiBA,OAAM,EAC7EpF,KAAM+E,EAAAA,EAAAA,SACN5E,KAAMgF,EAAOhF,KAEjB,IAEJ,CACA,IAAIH,IAAS8E,EAAAA,EAAAA,cAA0B9E,IAAS8E,EAAAA,EAAAA,cAAmC,IAATH,IACpEC,EAASe,gBAAiB,CAC5B,IAAMC,EAAe3E,EAAa2D,EAASe,iBACrCE,EAAiB7F,IAAS8E,EAAAA,EAAAA,aAAyBC,EAAAA,EAAAA,MAA2BA,EAAAA,EAAAA,MACpF,OAAOzD,EAASnD,EAAOyH,EAAa/D,KAAI,SAACiE,GACvC,IAAIV,EACJ,MAAO,CACLnD,MAAO6D,EAAMT,KACbE,OAAQC,OAAOM,EAAM3F,MACrBsF,cAA6C,QAA7BL,EAAMU,EAAMJ,mBAAiC,IAARN,EAAiBA,OAAM,EAC5EpF,KAAM6F,EACN1F,KAAM2F,EAAM3F,KAEhB,IACF,CAEF,GAAIH,IAAS8E,EAAAA,EAAAA,YAAwB9E,IAAS8E,EAAAA,EAAAA,YAAiC,IAATH,GAAc3E,IAAS8E,EAAAA,EAAAA,cAAmC,IAATH,GAAc3E,IAAS8E,EAAAA,EAAAA,UAA+B,IAATH,EAClK,OAAOoB,EAA6B5H,EAAOyG,EAAUT,EAAWjE,GAElE,GAAIF,IAAS8E,EAAAA,EAAAA,UAA+B,IAATH,EAAY,CAC7C,IAAMqB,GAAiBC,EAAAA,EAAAA,IAAarB,EAASsB,WAE7C,OAAO5E,EAASnD,EADYgI,EAAuBhC,EAAWjE,EAAQ/B,GAC3BuE,QAAO,SAAC0D,GAAC,OAAKA,EAAEb,UAA+B,OAAnBS,QAA8C,IAAnBA,OAA4B,EAASA,EAAeX,KAAK,IAC7J,CACA,OAAIrF,IAAS8E,EAAAA,EAAAA,gBAAqC,IAATH,GAAc3E,IAAS8E,EAAAA,EAAAA,YAA2C,MAAnB/E,EAAMgB,WAAqBhB,EAAMgB,UAAUf,OAAS8E,EAAAA,EAAAA,eACnIuB,EAAwClI,EAAOyG,EAAU1E,GAE9DF,IAAS8E,EAAAA,EAAAA,iBAAsC,IAATH,EACjC2B,EAAgCnI,EAAOyG,EAAU1E,EAAQiE,EAAW3F,MAAM+H,QAAQjC,GAAgBA,EAAeZ,EAAoBY,IAE1ItE,IAAS8E,EAAAA,EAAAA,qBAA0C,IAATH,GAAc3E,IAAS8E,EAAAA,EAAAA,WAAgC,IAATH,GAAc3E,IAAS8E,EAAAA,EAAAA,YAAwB/E,EAAMgB,YAAchB,EAAMgB,UAAUf,OAAS8E,EAAAA,EAAAA,qBAAiC/E,EAAMgB,UAAUf,OAAS8E,EAAAA,EAAAA,WAAuB/E,EAAMgB,UAAUf,OAAS8E,EAAAA,EAAAA,eACzR0B,EAAoCrI,EAAO+B,GAEhDF,IAAS8E,EAAAA,EAAAA,UACJ2B,EAA2BtI,EAAO4B,EAAOG,GAE3C,EACT,CACA9D,EAAO8H,EAA4B,8BACnC,IAAMwC,EAAe,cAGfC,EAAgCvK,GAAO,SAAC0J,GAC5C,IAAM3F,EAAO2F,EAAM3F,KACnB,IAAIM,EAAAA,EAAAA,IAAgBN,GAClB,OAAOuG,EAET,IAAIE,EAAAA,EAAAA,IAAWzG,KAASM,EAAAA,EAAAA,IAAgBN,EAAK0G,QAC3C,OAAOH,EAET,IAAII,EAAAA,EAAAA,IAAc3G,GAAO,CACvB,IAAIM,EAAAA,EAAAA,IAAgBN,EAAK0G,QACvB,OAAOH,EAET,IAAIE,EAAAA,EAAAA,IAAWzG,EAAK0G,UAAWpG,EAAAA,EAAAA,IAAgBN,EAAK0G,OAAOA,QACzD,OAAOH,CAEX,CACA,OAAO,IACT,GAAG,iBACH,SAASzB,EAA4B9G,EAAOyG,EAAUL,GACpD,IAAIN,EACJ,GAAIW,EAASmC,WAAY,CACvB,IAAMA,EAAanC,EAASmC,WACxBC,EAAS,GAUb,MATI,cAAeD,IACjBC,EAAS/F,EAAa8F,EAAWrG,eAE/BD,EAAAA,EAAAA,IAAgBsG,IAClBC,EAAOlG,KAAKmG,EAAAA,IAEVF,KAA4F,QAA3E9C,EAAiB,OAAZM,QAAgC,IAAZA,OAAqB,EAASA,EAAQrE,cAA2B,IAAP+D,OAAgB,EAASA,EAAG3D,iBAClI0G,EAAOlG,KAAKoG,EAAAA,GAAsBC,EAAAA,IAE7B7F,EAASnD,EAAO6I,EAAOnF,KAAI,SAACiE,EAAOsB,GACxC,IAAIhC,EACEvC,EAAa,CACjBwE,SAAU7B,OAAO4B,GAAStB,EAAMT,KAChCpD,MAAO6D,EAAMT,KACbE,OAAQC,OAAOM,EAAM3F,MACrBsF,cAA6C,QAA7BL,EAAMU,EAAMJ,mBAAiC,IAARN,EAAiBA,OAAM,EAC5EkC,WAAYC,QAAQzB,EAAM0B,mBAC1BrF,aAAcoF,QAAQzB,EAAM0B,mBAC5BA,kBAAmB1B,EAAM0B,kBACzBxH,KAAM+E,EAAAA,EAAAA,MACN5E,KAAM2F,EAAM3F,MAERmF,EAAaqB,EAAcb,GAMjC,OALIR,IACFzC,EAAWyC,WAAaQ,EAAMT,KAAOC,EACrCzC,EAAW4E,iBAAmBC,EAAAA,EAAAA,QAC9B7E,EAAWW,QAAUD,GAEhBV,CACT,IACF,CACA,MAAO,EACT,CAEA,SAASkD,EAA6B5H,EAAOyG,EAAUT,EAAWjE,GAChE,IAAM8F,GAAiBC,EAAAA,EAAAA,IAAarB,EAASsB,WACvCyB,EAAiBxB,EAAuBhC,EAAWjE,EAAQ/B,GAAOuE,QAAO,SAAC0D,GAAC,OAAKA,EAAEb,SAAWS,EAAeX,IAAI,IACtH,OAAIW,aAA0B4B,EAAAA,GAErBtG,EAASnD,EADD6H,EAAe6B,YACAhG,KAAI,SAACvF,GACjC,IAAI2H,EACJ,MAAO,CACLhC,MAAO3F,EAAM+I,KACbE,OAAQC,OAAOQ,GACfP,cAA4C,QAA5BxB,EAAK3H,EAAMoJ,mBAAgC,IAAPzB,EAAgBA,OAAK,EACzEqD,WAAYC,QAAQjL,EAAMkL,mBAC1BrF,aAAcoF,QAAQjL,EAAMkL,mBAC5BA,kBAAmBlL,EAAMkL,kBACzBxH,KAAM+E,EAAAA,EAAAA,WACN5E,KAAM6F,EAEV,IAAG8B,OAAOH,IACD3B,IAAmB+B,EAAAA,GACrBzG,EAASnD,EAAOwJ,EAAeG,OAAO,CAC3C,CACE7F,MAAO,OACPsD,OAAQC,OAAOuC,EAAAA,IACftC,cAAe,aACfzF,KAAM+E,EAAAA,EAAAA,SACN5E,KAAM4H,EAAAA,IAER,CACE9F,MAAO,QACPsD,OAAQC,OAAOuC,EAAAA,IACftC,cAAe,YACfzF,KAAM+E,EAAAA,EAAAA,SACN5E,KAAM4H,EAAAA,OAILJ,CACT,CAEA,SAAS3C,EAA4B7G,EAAOyB,EAAYM,EAAQ8H,EAAcpD,GAC5E,GAAIhF,EAAWqI,eACb,MAAO,GAET,IACMC,EAAmBjH,EADTf,EAAOiI,cACwBzF,OAAO0F,EAAAA,IAChDC,EAAuBH,EAAiBrG,KAAI,YAAO,SAAJwD,IAAe,IAC9DiD,EAAmC,IAAIC,IAC7CC,EAAgBR,GAAc,SAACS,EAAG1I,GAChC,IAAIkE,EAAIyE,EAAIC,EAAIC,EAAIC,EACpB,GAAI9I,EAAMsF,OACJtF,EAAMC,OAAS8E,EAAAA,EAAAA,eAA4BuD,EAAqBS,SAAS/I,EAAMsF,OACjFiD,EAAiBS,IAAIhJ,EAAMsF,MAEzBtF,EAAMC,OAAS8E,EAAAA,EAAAA,aAAoD,QAA1Bb,EAAKlE,EAAMgB,iBAA8B,IAAPkD,OAAgB,EAASA,EAAGjE,QAAU8E,EAAAA,EAAAA,YACnH,GAAIF,EAASoE,aAAc,CAEzB,GADsD,QAAhCN,EAAK9D,EAASoE,oBAAiC,IAAPN,OAAgB,EAASA,EAAGO,gBAAgBC,MAAK,YAAO,SAAJ7D,OAAoBtF,EAAMsF,IAAI,IAE9I,OAEF,IAAMlF,EAAOD,EAAOiJ,QAAQpJ,EAAMsF,MAC5B+D,EAAmD,QAAhCT,EAAK/D,EAASoE,oBAAiC,IAAPL,OAAgB,EAASA,EAAGU,WAC7FzE,EAASoE,aAAe,IAAIM,EAAAA,GAAqBpN,OAAOuI,OAAOvI,OAAOuI,OAAO,CAAC,EAAG2E,GAAkB,CAAEG,WAAY,GAAF,eAC1GH,EAAgBG,YAAU,CAC7BpJ,GAAQ,IAAImJ,EAAAA,GAAqB,CAAEjE,KAAMtF,EAAMsF,KAAM2B,OAAQ,CAAC,QAElE,MAAO,GAAIpC,EAAS4E,cAAe,CAEjC,GADuD,QAAjCZ,EAAKhE,EAAS4E,qBAAkC,IAAPZ,OAAgB,EAASA,EAAGK,gBAAgBC,MAAK,YAAO,SAAJ7D,OAAoBtF,EAAMsF,IAAI,IAE/I,OAEF,IAAMlF,EAAOD,EAAOiJ,QAAQpJ,EAAMsF,MAC5BoE,EAAqD,QAAjCZ,EAAKjE,EAAS4E,qBAAkC,IAAPX,OAAgB,EAASA,EAAGQ,WAC/FzE,EAAS4E,cAAgB,IAAIE,EAAAA,GAAkBxN,OAAOuI,OAAOvI,OAAOuI,OAAO,CAAC,EAAGgF,GAAmB,CAAEF,WAAY,GAAF,eACzGE,EAAiBF,YAAU,CAC9BpJ,GAAQ,IAAImJ,EAAAA,GAAqB,CAAEjE,KAAMtF,EAAMsF,KAAM2B,OAAQ,CAAC,QAElE,CAGN,IACA,IAAM2C,EAAsB/E,EAASoE,cAAgBpE,EAAS4E,cAExDI,IAD6C,OAAxBD,QAAwD,IAAxBA,OAAiC,EAASA,EAAoBV,kBAAoB,IAC7FpH,KAAI,YAAO,SAAJwD,IAAe,IAEtE,OAAO/D,EAASnD,EADW+J,EAAiBJ,QAAO,OAAIQ,GAAkBzG,KAAI,SAACwD,GAAI,MAAM,CAAEA,KAAAA,EAAM,KAAI3C,QAAO,gBAAG2C,EAAI,EAAJA,KAAI,OAAOA,KAAkC,OAAxBsE,QAAwD,IAAxBA,OAAiC,EAASA,EAAoBtE,QAAUuE,EAAsBd,SAASzD,EAAK,IACrOxD,KAAI,SAAC1B,GAC7C,IAAM0J,EAAS,CACb5H,MAAO9B,EAAKkF,KACZrF,KAAM+E,EAAAA,EAAAA,UACN5E,KAAAA,GAKF,OAHa,OAATA,QAA0B,IAATA,OAAkB,EAASA,EAAKuF,eACnDmE,EAAOpE,cAAgBtF,EAAKuF,aAEvBmE,CACT,IACF,CAEA,SAASxD,EAAwClI,EAAOyG,EAAU1E,EAAQ4J,GACxE,IAAIC,EACJ,GAAInF,EAASmC,WACX,IAAIiD,EAAAA,EAAAA,IAAepF,EAASmC,YAAa,CACvC,IAAMkD,GAAeC,EAAAA,EAAAA,IAAmBtF,EAASmC,YAC3CoD,EAAmBjK,EAAOkK,iBAAiBH,GAC3CI,EAAmCnO,OAAOoO,OAAO,MACvDH,EAAiBI,SAAQ,SAACpK,GACxBA,EAAK8I,gBAAgBsB,SAAQ,SAACC,GAC5BH,EAAiBG,EAAMnF,MAAQmF,CACjC,GACF,IACAT,EAAgBI,EAAiBrC,OAAO7G,EAAaoJ,GACvD,MACEN,EAAgB,CAACnF,EAASmC,iBAI5BgD,EAAgB9I,EADAf,EAAOiI,cACezF,OAAOjC,EAAAA,IAE/C,OAAOa,EAASnD,EAAO4L,EAAclI,KAAI,SAAC1B,GACxC,IAAMsK,GAAYxE,EAAAA,EAAAA,IAAa9F,GAC/B,MAAO,CACL8B,MAAOuD,OAAOrF,GACdsF,eAA8B,OAAdgF,QAAoC,IAAdA,OAAuB,EAASA,EAAU/E,cAAgB,GAChG1F,KAAM+E,EAAAA,EAAAA,MAEV,IACF,CAEA,SAASuB,EAAgCnI,EAAOyG,EAAU1E,EAAQiE,EAAWG,GAC3E,IAAKH,EACH,MAAO,GAET,IAAMuG,EAAUxK,EAAOiI,aACjBwC,EAAWhL,EAAmBxB,EAAM4B,OACpC6K,EAAYC,EAAuB1G,GAKzC,OAJIG,GAAgBA,EAAarH,OAAS,GACxC2N,EAAU9J,KAAI,MAAd8J,GAAS,OAAStG,IAGbhD,EAASnD,EADMyM,EAAUlI,QAAO,SAACoI,GAAI,OAAKJ,EAAQI,EAAKC,cAAc1F,KAAK/I,UAAYqO,GAAYA,EAAS3K,OAAS8E,EAAAA,EAAAA,qBAAiC6F,EAAStF,OAASyF,EAAKzF,KAAK/I,SAAUmE,EAAAA,EAAAA,IAAgBmE,EAASmC,cAAetG,EAAAA,EAAAA,IAAgBiK,EAAQI,EAAKC,cAAc1F,KAAK/I,UAAW0O,EAAAA,EAAAA,IAAe9K,EAAQ0E,EAASmC,WAAY2D,EAAQI,EAAKC,cAAc1F,KAAK/I,OAAO,IACnVuF,KAAI,SAACiJ,GAAI,MAAM,CAClD7I,MAAO6I,EAAKzF,KAAK/I,MACjBiJ,OAAQC,OAAOkF,EAAQI,EAAKC,cAAc1F,KAAK/I,QAC/CmJ,cAAe,YAAF,OAAcqF,EAAKzF,KAAK/I,MAAK,eAAOwO,EAAKC,cAAc1F,KAAK/I,OACzE0D,KAAM+E,EAAAA,EAAAA,MACN5E,KAAMuK,EAAQI,EAAKC,cAAc1F,KAAK/I,OACvC,IACH,CAlJAF,EAAO6I,EAA6B,+BAuCpC7I,EAAO2J,EAA8B,gCA0DrC3J,EAAO4I,EAA6B,+BA8BpC5I,EAAOiK,EAAyC,2CAoBhDjK,EAAOkK,EAAiC,mCACxC,IAAM2E,EAAsC7O,GAAO,SAAC2D,EAAOC,GACzD,IAAIiE,EAAIyE,EAAIC,EAAIC,EAAIC,EAAIqC,EAAIC,EAAIC,EAAIC,EAAIC,EACxC,OAAgC,QAA1BrH,EAAKlE,EAAMgB,iBAA8B,IAAPkD,OAAgB,EAASA,EAAGjE,QAAUA,EACrED,EAAMgB,WAE0E,QAAnF4H,EAAgC,QAA1BD,EAAK3I,EAAMgB,iBAA8B,IAAP2H,OAAgB,EAASA,EAAG3H,iBAA8B,IAAP4H,OAAgB,EAASA,EAAG3I,QAAUA,EAC9HD,EAAMgB,UAAUA,WAEyH,QAA5ImK,EAAyF,QAAnFrC,EAAgC,QAA1BD,EAAK7I,EAAMgB,iBAA8B,IAAP6H,OAAgB,EAASA,EAAG7H,iBAA8B,IAAP8H,OAAgB,EAASA,EAAG9H,iBAA8B,IAAPmK,OAAgB,EAASA,EAAGlL,QAAUA,EACvLD,EAAMgB,UAAUA,UAAUA,WAEwK,QAArMuK,EAAkJ,QAA5ID,EAAyF,QAAnFD,EAAgC,QAA1BD,EAAKpL,EAAMgB,iBAA8B,IAAPoK,OAAgB,EAASA,EAAGpK,iBAA8B,IAAPqK,OAAgB,EAASA,EAAGrK,iBAA8B,IAAPsK,OAAgB,EAASA,EAAGtK,iBAA8B,IAAPuK,OAAgB,EAASA,EAAGtL,QAAUA,EAChPD,EAAMgB,UAAUA,UAAUA,UAAUA,eAD7C,CAGF,GAAG,uBACH,SAASoF,EAAuBhC,EAAWjE,EAAQ/B,GACjD,IACIoN,EADAC,EAAe,KAEbC,EAA8BvP,OAAOoO,OAAO,CAAC,GAyBnD,OAxBA9B,EAAgBrE,GAAW,SAACsE,EAAG1I,GAI7B,IAHe,OAAVA,QAA4B,IAAVA,OAAmB,EAASA,EAAMC,QAAU8E,EAAAA,EAAAA,UAAsB/E,EAAMsF,OAC7FmG,EAAezL,EAAMsF,OAER,OAAVtF,QAA4B,IAAVA,OAAmB,EAASA,EAAMC,QAAU8E,EAAAA,EAAAA,YAAwB0G,EAAc,CACvG,IAAME,EAAmBT,EAAoBlL,EAAO+E,EAAAA,EAAAA,OAC3B,OAArB4G,QAAkD,IAArBA,OAA8B,EAASA,EAAiBvL,QACvFoL,EAAerL,EAAOiJ,QAA6B,OAArBuC,QAAkD,IAArBA,OAA8B,EAASA,EAAiBvL,MAEvH,CACIqL,GAAgBD,IACbE,EAAYD,KACfC,EAAYD,GAAgB,CAC1BjG,OAAQgG,EAAaI,WACrBrG,WAA6B,MAAjBnH,EAAMuD,OAAiB8J,EAAe,IAAMA,EACxDvJ,MAAOuJ,EACPrL,KAAMoL,EACNvL,KAAM+E,EAAAA,EAAAA,UAERyG,EAAe,KACfD,EAAe,MAGrB,IACOtK,EAAawK,EACtB,CAEA,SAASZ,EAAuB1G,GAC9B,IAAMG,EAAe,GAuBrB,OAtBAkE,EAAgBrE,GAAW,SAACsE,EAAG1I,GACzBA,EAAMC,OAAS8E,EAAAA,EAAAA,qBAAiC/E,EAAMsF,MAAQtF,EAAMI,MACtEmE,EAAaxD,KAAK,CAChBd,KAAM8E,EAAAA,EAAAA,oBACNO,KAAM,CACJrF,KAAM4L,EAAAA,EAAAA,KACNtP,MAAOyD,EAAMsF,MAEfwG,aAAc,CACZ7L,KAAM8E,EAAAA,EAAAA,cACNgH,WAAY,IAEdf,cAAe,CACb/K,KAAM8E,EAAAA,EAAAA,WACNO,KAAM,CACJrF,KAAM4L,EAAAA,EAAAA,KACNtP,MAAOyD,EAAMI,QAKvB,IACOmE,CACT,CAEA,SAASkC,EAAoCrI,EAAO+B,EAAQ4J,GAG1D,OAAOxI,EAASnD,EADG8C,EADEf,EAAOiI,cACkBzF,OAAOqJ,EAAAA,IACnBlK,KAAI,SAAC1B,GAAI,MAAM,CAC/C8B,MAAO9B,EAAKkF,KACZI,cAAetF,EAAKuF,YACpB1F,KAAM+E,EAAAA,EAAAA,SACP,IACH,CAEA,SAAS0B,EAA2BtI,EAAO4B,EAAOG,EAAQ4J,GACxD,IAAI7F,EACJ,OAA+B,QAA1BA,EAAKlE,EAAMgB,iBAA8B,IAAPkD,OAAgB,EAASA,EAAGjE,MAE1DsB,EAASnD,EADG+B,EAAO8L,gBAAgBtJ,QAAO,SAACuJ,GAAS,OAAKC,EAAgBnM,EAAMgB,UAAWkL,EAAU,IACzEpK,KAAI,SAACoK,GAAS,MAAM,CACpDhK,MAAOgK,EAAU5G,KACjBI,cAAewG,EAAUvG,aAAe,GACxC1F,KAAM+E,EAAAA,EAAAA,SACP,KAEI,EACT,CAEA,SAASL,EAAmBP,EAAWC,GACrC,IAAI+H,EAAgB,KAChBC,EAAgB,KAChBC,EAAiB,KACflO,EAAQqK,EAAgBrE,GAAW,SAACmI,EAAQvM,EAAOwM,EAAOnF,GAC9D,GAAIA,IAAUhD,EAAO5E,MACf8M,EAAOzP,sBAAwBuH,EAAOjF,UAIxC,OAHAgN,EAAgBI,EAChBH,EAAgBlQ,OAAOuI,OAAO,CAAC,EAAG1E,GAClCsM,EAAiBC,EAAOpN,UACjB,OAGb,IACA,MAAO,CACLG,MAAOlB,EAAMkB,MACbC,IAAKnB,EAAMmB,IACXoC,OAAQ2K,GAAkBlO,EAAMuD,OAChC3B,MAAOqM,GAAiBjO,EAAM4B,MAC9BwM,MAAOJ,GAAiBhO,EAAMoO,MAElC,CAEA,SAAS/D,EAAgBrE,EAAWqI,GAMlC,IALA,IAAMC,EAAQtI,EAAUuI,MAAM,MACxBC,GAASC,EAAAA,EAAAA,KACX7M,EAAQ4M,EAAOE,aACfN,EAAQ,GACRD,EAAS,IAAI9P,EAAAA,EAAgB,IACxBwE,EAAI,EAAGA,EAAIyL,EAAMxP,OAAQ+D,IAAK,CAErC,IADAsL,EAAS,IAAI9P,EAAAA,EAAgBiQ,EAAMzL,KAC3BsL,EAAOvP,OAAO,CAGpB,GAAa,UADAyP,EAASF,EAAQvM,EAD9BwM,EAAQI,EAAOxO,MAAMmO,EAAQvM,GACeiB,GAE1C,KAEJ,CACAwL,EAASF,EAAQvM,EAAOwM,EAAOvL,GAC1BjB,EAAMC,OACTD,EAAQ4M,EAAOE,aAEnB,CACA,MAAO,CACLxN,MAAOiN,EAAO3P,kBACd2C,IAAKgN,EAAOzP,qBACZ6E,OAAQ4K,EAAOpN,UACfa,MAAAA,EACAwM,MAAAA,EAEJ,CAEA,SAASL,EAAgBnM,EAAOkM,GAC9B,IAAIhI,EACJ,IAAKlE,IAAUA,EAAMC,KACnB,OAAO,EAET,IAAMA,EAAOD,EAAMC,KACb8M,EAAYb,EAAUa,UAC5B,OAAQ9M,GACN,KAAK8E,EAAAA,EAAAA,MACH,OAAuD,IAAhDgI,EAAU/J,QAAQgK,EAAAA,EAAAA,OAC3B,KAAKjI,EAAAA,EAAAA,SACH,OAA0D,IAAnDgI,EAAU/J,QAAQgK,EAAAA,EAAAA,UAC3B,KAAKjI,EAAAA,EAAAA,aACH,OAA8D,IAAvDgI,EAAU/J,QAAQgK,EAAAA,EAAAA,cAC3B,KAAKjI,EAAAA,EAAAA,MACL,KAAKA,EAAAA,EAAAA,cACH,OAAuD,IAAhDgI,EAAU/J,QAAQgK,EAAAA,EAAAA,OAC3B,KAAKjI,EAAAA,EAAAA,oBACH,OAAqE,IAA9DgI,EAAU/J,QAAQgK,EAAAA,EAAAA,qBAC3B,KAAKjI,EAAAA,EAAAA,gBACH,OAAiE,IAA1DgI,EAAU/J,QAAQgK,EAAAA,EAAAA,iBAC3B,KAAKjI,EAAAA,EAAAA,gBACH,OAAiE,IAA1DgI,EAAU/J,QAAQgK,EAAAA,EAAAA,iBAC3B,KAAKjI,EAAAA,EAAAA,WACH,OAAwD,IAAjDgI,EAAU/J,QAAQgK,EAAAA,EAAAA,QAC3B,KAAKjI,EAAAA,EAAAA,WACH,OAAwD,IAAjDgI,EAAU/J,QAAQgK,EAAAA,EAAAA,QAC3B,KAAKjI,EAAAA,EAAAA,gBACH,OAAwD,IAAjDgI,EAAU/J,QAAQgK,EAAAA,EAAAA,QAC3B,KAAKjI,EAAAA,EAAAA,UACH,OAAkE,IAA3DgI,EAAU/J,QAAQgK,EAAAA,EAAAA,kBAC3B,KAAKjI,EAAAA,EAAAA,cACH,OAA2D,IAApDgI,EAAU/J,QAAQgK,EAAAA,EAAAA,WAC3B,KAAKjI,EAAAA,EAAAA,UACH,OAAuD,IAAhDgI,EAAU/J,QAAQgK,EAAAA,EAAAA,OAC3B,KAAKjI,EAAAA,EAAAA,SACH,OAAsD,IAA/CgI,EAAU/J,QAAQgK,EAAAA,EAAAA,MAC3B,KAAKjI,EAAAA,EAAAA,WACH,OAA4D,IAArDgI,EAAU/J,QAAQgK,EAAAA,EAAAA,YAC3B,KAAKjI,EAAAA,EAAAA,UACH,OAA8D,IAAvDgI,EAAU/J,QAAQgK,EAAAA,EAAAA,cAC3B,KAAKjI,EAAAA,EAAAA,gBAEH,OADiD,QAA1Bb,EAAKlE,EAAMgB,iBAA8B,IAAPkD,OAAgB,EAASA,EAAGjE,MAEnF,KAAK8E,EAAAA,EAAAA,cACH,OAAqE,IAA9DgI,EAAU/J,QAAQgK,EAAAA,EAAAA,qBAC3B,KAAKjI,EAAAA,EAAAA,UACH,OAAwE,IAAjEgI,EAAU/J,QAAQgK,EAAAA,EAAAA,yBAGjC,OAAO,CACT,CAEA,SAASlI,EAAY3E,EAAQN,GAC3B,IAAIuF,EACAD,EACA8H,EACAC,EACAC,EACAhH,EACAsD,EACA7D,EACAoB,EACA5G,EACA6I,EA0HJ,OAzHAlJ,EAAaF,GAAY,SAACG,GACxB,IAAIkE,EACJ,OAAQlE,EAAMC,MACZ,KAAK8E,EAAAA,EAAAA,MACL,IAAK,aACH3E,EAAOD,EAAOI,eACd,MACF,KAAKwE,EAAAA,EAAAA,SACH3E,EAAOD,EAAOiN,kBACd,MACF,KAAKrI,EAAAA,EAAAA,aACH3E,EAAOD,EAAOkN,sBACd,MACF,KAAKtI,EAAAA,EAAAA,gBACL,KAAKA,EAAAA,EAAAA,oBACC/E,EAAMI,OACRA,EAAOD,EAAOiJ,QAAQpJ,EAAMI,OAE9B,MACF,KAAK2E,EAAAA,EAAAA,MACL,KAAKA,EAAAA,EAAAA,cACE3E,GAASJ,EAAMsF,MAGlB6H,EAAWnG,EAAa9G,EAAYC,EAAQ6G,EAAYhH,EAAMsF,MAAQ,KACtElF,EAAO+M,EAAWA,EAAS/M,KAAO,MAHlC+M,EAAW,KAKb,MAEF,KAAKpI,EAAAA,EAAAA,cACHiC,GAAad,EAAAA,EAAAA,IAAa9F,GAC1B,MACF,KAAK2E,EAAAA,EAAAA,UACHkI,EAAejN,EAAMsF,KAAOnF,EAAOmN,aAAatN,EAAMsF,MAAQ,KAC9D,MACF,KAAKP,EAAAA,EAAAA,cACC/E,EAAMsF,OACRmE,EAAgB,KAChBR,EAAe,IAAIM,EAAAA,GAAqB,CACtCjE,KAAMtF,EAAMsF,KACZkE,WAAY,GACZvC,OAAQ,CAAC,KAGb,MACF,KAAKlC,EAAAA,EAAAA,gBACC/E,EAAMsF,OACR2D,EAAe,KACfQ,EAAgB,IAAIE,EAAAA,GAAkB,CACpCrE,KAAMtF,EAAMsF,KACZkE,WAAY,GACZvC,OAAQ,CAAC,KAGb,MACF,KAAKlC,EAAAA,EAAAA,UACH,GAAK/E,EAAMgB,UAGT,OAAQhB,EAAMgB,UAAUf,MACtB,KAAK8E,EAAAA,EAAAA,MACHI,EAAUgI,GAAYA,EAASI,KAC/B,MACF,KAAKxI,EAAAA,EAAAA,UACHI,EAAU8H,GAAgBA,EAAaM,KACvC,MACF,KAAKxI,EAAAA,EAAAA,cACH,IAAMO,EAAkC,QAA1BpB,EAAKlE,EAAMgB,iBAA8B,IAAPkD,OAAgB,EAASA,EAAGoB,KAC5E,IAAKA,EAAM,CACTH,EAAU,KACV,KACF,CACA,IAAMY,EAAQiB,EAAa9G,EAAYC,EAAQ6G,EAAY1B,GAAQ,KACnE,IAAKS,EAAO,CACVZ,EAAU,KACV,KACF,CACAA,EAAUY,EAAMwH,KAChB,MAEF,QACEpI,EAAU,UAxBdA,EAAU,KA4BZ,MAEF,KAAKJ,EAAAA,EAAAA,SACH,GAAII,EACF,IAAK,IAAIlE,EAAI,EAAGA,EAAIkE,EAAQjI,OAAQ+D,IAClC,GAAIkE,EAAQlE,GAAGqE,OAAStF,EAAMsF,KAAM,CAClCF,EAASD,EAAQlE,GACjB,KACF,CAGJkF,EAAuB,OAAXf,QAA8B,IAAXA,OAAoB,EAASA,EAAOhF,KACnE,MACF,KAAK2E,EAAAA,EAAAA,WACH,IAAMyI,GAAWtH,EAAAA,EAAAA,IAAaC,GAC9B+G,EAAYM,aAAoB3F,EAAAA,GAAkB2F,EAAS1F,YAAYqB,MAAK,SAACsE,GAAG,OAAKA,EAAIlR,QAAUyD,EAAMsF,IAAI,IAAI,KACjH,MACF,KAAKP,EAAAA,EAAAA,WACH,IAAM2I,GAAeC,EAAAA,EAAAA,IAAgBxH,GACrCA,EAAYuH,aAAwBE,EAAAA,GAAcF,EAAa5G,OAAS,KACxE,MACF,KAAK/B,EAAAA,EAAAA,aACH,IAAM8I,GAAa3H,EAAAA,EAAAA,IAAaC,GAChCP,EAAkBiI,aAAsBC,EAAAA,GAAyBD,EAAWlN,YAAc,KAC1F,MACF,KAAKoE,EAAAA,EAAAA,aACH,IAAMgJ,EAAc/N,EAAMsF,MAAQM,EAAkBA,EAAgB5F,EAAMsF,MAAQ,KAClFa,EAA4B,OAAhB4H,QAAwC,IAAhBA,OAAyB,EAASA,EAAY3N,KAClF,MACF,KAAK2E,EAAAA,EAAAA,WACC/E,EAAMsF,OACRlF,EAAOD,EAAOiJ,QAAQpJ,EAAMsF,OAIpC,IACO,CACLF,OAAAA,EACAD,QAAAA,EACA8H,aAAAA,EACAC,UAAAA,EACAC,SAAAA,EACAhH,UAAAA,EACAP,gBAAAA,EACAoB,WAAAA,EACA5G,KAAAA,EACA6I,aAAAA,EACAQ,cAAAA,EAEJ,CA9SApN,EAAO+J,EAAwB,0BA2B/B/J,EAAOyO,EAAwB,0BAU/BzO,EAAOoK,EAAqC,uCAa5CpK,EAAOqK,EAA4B,8BAuBnCrK,EAAOsI,EAAoB,sBA6B3BtI,EAAOoM,EAAiB,mBAqDxBpM,EAAO8P,EAAiB,mBAoJxB9P,EAAOyI,EAAa,eACpBkJ,EAAAA,EAAAA,eAA0B,OAAQ,WAAW,SAACC,EAAQzJ,GACpD,IAAMrE,EAASqE,EAAQrE,OACvB,GAAKA,EAAL,CAGA,IAAM+N,EAAMD,EAAOE,YACb/P,EAAQ6P,EAAOG,WAAWF,GAC1BG,EAA4B,OAAfjQ,EAAMgC,MAAiB,OAAO9B,KAAKF,EAAMuD,OAAO,IAAMvD,EAAMkB,MAAQlB,EAAMmB,IACvFrB,EAAW,IAAIwB,EAAAA,EAASwO,EAAIzO,KAAM4O,GAElCC,EAAU,CACd9M,KAFiB2C,EAA2BhE,EAAQ8N,EAAOM,WAAYrQ,EAAUE,EAAOoG,EAAQX,mBAE/E/B,KAAI,SAAC0M,GAAI,MAAM,CAC9B5M,KAAM4M,EAAKtM,MACX9B,KAAMoO,EAAKpO,KACXuF,YAAa6I,EAAK9I,cAClBtD,aAAcoM,EAAKpM,aACnBqF,kBAAmB+G,EAAK/G,kBACzB,IACDgH,KAAM,CAAEhP,KAAMyO,EAAIzO,KAAMiP,GAAIL,GAC5BM,GAAI,CAAElP,KAAMyO,EAAIzO,KAAMiP,GAAItQ,EAAMmB,MAOlC,OALiB,OAAZ+O,QAAgC,IAAZA,OAAqB,EAASA,EAAQ9M,OAAS8M,EAAQ9M,KAAKtE,OAAS,IAC5FoR,EAAQG,KAAOT,EAAAA,EAAAA,IAAeM,EAAQG,KAAKhP,KAAM6O,EAAQG,KAAKC,IAC9DJ,EAAQK,GAAKX,EAAAA,EAAAA,IAAeM,EAAQK,GAAGlP,KAAM6O,EAAQK,GAAGD,IACxDV,EAAAA,EAAAA,OAAkBC,EAAQ,gBAAiBA,EAAQK,EAASlQ,IAEvDkQ,CAtBP,CAuBF,G,+ECtyBIpS,EAAYC,OAAOC,eACnBC,EAAS,SAACC,EAAQC,GAAK,OAAKL,EAAUI,EAAQ,OAAQ,CAAEC,MAAAA,EAAOC,cAAc,GAAO,EAGxF,SAASqQ,IAKN,IALmBrI,EAAU,UAAH,6CAAG,CAC9BoK,cAAe,SAACrC,GAAM,OAAKA,EAAO5O,SAASkR,EAAAA,EAAU,EACrDC,SAAUC,EAAAA,EACVC,WAAYC,EAAAA,EACZC,aAAc,CAAC,GAEf,MAAO,CACLpC,WAAU,WACR,IAAMqC,EAAe,CACnBC,MAAO,EACPxK,KAAM,EACNU,KAAM,KACNrF,KAAM,KACNG,KAAM,KACNiP,KAAM,KACNnH,gBAAgB,EAChBlH,UAAW,MAGb,OADAsO,EAAS9K,EAAQwK,WAAYG,EAActD,EAAAA,EAAAA,UACpCsD,CACT,EACA/Q,MAAK,SAACmO,EAAQvM,GACZ,OAAOuP,EAAShD,EAAQvM,EAAOwE,EACjC,EAEJ,CAEA,SAAS+K,EAAShD,EAAQvM,EAAOwE,GAC/B,IAAIN,EACJ,GAAIlE,EAAMwP,cACR,OAAIjD,EAAO3O,MAAM,UACfoC,EAAMwP,eAAgB,EACf,WAEPjD,EAAOvO,YACA,UAGX,IAAQ8Q,EAAsDtK,EAAtDsK,SAAUE,EAA4CxK,EAA5CwK,WAAYJ,EAAgCpK,EAAhCoK,cAAeM,EAAiB1K,EAAjB0K,aAO7C,GANIlP,EAAMqP,MAA8B,IAAtBrP,EAAMqP,KAAKnS,OAC3BuS,EAAQzP,GACCA,EAAM0P,eACf1P,EAAM0P,cAAe,EACrBC,EAAY3P,GAAO,IAEjBuM,EAAOpP,MAAO,CAChB,IAAMyS,GAA4B,OAAjBV,QAA0C,IAAjBA,OAA0B,EAASA,EAAaU,UAAY,EACtG5P,EAAM6P,YAAcvM,KAAKwM,MAAMvD,EAAOzN,cAAgB8Q,EACxD,CACA,GAAIhB,EAAcrC,GAChB,MAAO,KAET,IAAMnO,EAAQ2R,EAAIjB,EAAUvC,GAC5B,IAAKnO,EAMH,OALyBmO,EAAO3O,MAAM,QAEpC2O,EAAO3O,MAAM,MAEf0R,EAASU,EAAmBhQ,EAAO,WAC5B,cAET,GAAmB,YAAf5B,EAAM6B,KAER,OADAqP,EAASU,EAAmBhQ,EAAO,WAC5B,UAET,IAAMiQ,EAAcvL,EAAO,CAAC,EAAG1E,GAC/B,GAAmB,gBAAf5B,EAAM6B,KACR,GAAI,SAAS3B,KAAKF,EAAM7B,YACI,IAAtByD,EAAM6P,cACR7P,EAAMkQ,QAAUlQ,EAAMkQ,QAAU,IAAInI,OAAO/H,EAAM6P,YAAc,SAE5D,GAAI,UAAUvR,KAAKF,EAAM7B,OAAQ,CACtC,IAAM2T,EAASlQ,EAAMkQ,QAAUlQ,EAAMkQ,QAAU,IAAI1R,MAAM,GAAI,GACzDwB,EAAM6P,aACJK,EAAOhT,OAAS,GAAKgT,EAAOA,EAAOhT,OAAS,GAAK8C,EAAM6P,cACzD7P,EAAM6P,YAAcK,EAAOA,EAAOhT,OAAS,GAGjD,CAEF,KAAO8C,EAAMqP,MAAM,CACjB,IAAIc,EAAiC,oBAAfnQ,EAAMqP,KAAqC,IAAfrP,EAAM4E,KAAa5E,EAAMqP,KAAKjR,EAAOmO,GAAU,KAAOvM,EAAMqP,KAAKrP,EAAM4E,MAIzH,GAHI5E,EAAMkI,iBACRiI,EAAwB,OAAbA,QAAkC,IAAbA,OAAsB,EAASA,EAASC,WAEtED,EAAU,CAIZ,GAHIA,EAASE,SACXF,EAAWA,EAASE,QAEE,kBAAbF,EAAuB,CAChCb,EAASN,EAAYhP,EAAOmQ,GAC5B,QACF,CACA,GAA8B,QAAzBjM,EAAKiM,EAASvS,aAA0B,IAAPsG,OAAgB,EAASA,EAAGoM,KAAKH,EAAU/R,GAS/E,OARI+R,EAASI,QACXJ,EAASI,OAAOvQ,EAAO5B,GAEN,gBAAfA,EAAM6B,KACR0P,EAAY3P,GAAO,GAEnBA,EAAM0P,cAAe,EAEhBS,EAAS3D,KAEpB,CACAgE,EAAaxQ,EACf,CAGA,OAFA0E,EAAO1E,EAAOiQ,GACdX,EAASU,EAAmBhQ,EAAO,WAC5B,aACT,CAEA,SAAS0E,EAAOiK,EAAIF,GAElB,IADA,IAAMrN,EAAOjF,OAAOiF,KAAKqN,GAChBxN,EAAI,EAAGA,EAAIG,EAAKlE,OAAQ+D,IAC/B0N,EAAGvN,EAAKH,IAAMwN,EAAKrN,EAAKH,IAE1B,OAAO0N,CACT,CA5FAtS,EAAOwQ,EAAc,gBAqFrBxQ,EAAOkT,EAAU,YAQjBlT,EAAOqI,EAAQ,UACf,IAAMsL,EAAoB,CACxBS,QAAS,GACTC,QAAS,IAEX,SAASpB,EAASqB,EAAO3Q,EAAO4Q,GAC9B,IAAKD,EAAMC,GACT,MAAM,IAAIC,UAAU,iBAAmBD,GAEzC5Q,EAAMgB,UAAY7E,OAAOuI,OAAO,CAAC,EAAG1E,GACpCA,EAAMC,KAAO2Q,EACb5Q,EAAMsF,KAAO,KACbtF,EAAMI,KAAO,KACbJ,EAAMqP,KAAOsB,EAAMC,GACnB5Q,EAAM4E,KAAO,EACb5E,EAAMkI,gBAAiB,CACzB,CAEA,SAASuH,EAAQzP,GACVA,EAAMgB,YAGXhB,EAAMC,KAAOD,EAAMgB,UAAUf,KAC7BD,EAAMsF,KAAOtF,EAAMgB,UAAUsE,KAC7BtF,EAAMI,KAAOJ,EAAMgB,UAAUZ,KAC7BJ,EAAMqP,KAAOrP,EAAMgB,UAAUqO,KAC7BrP,EAAM4E,KAAO5E,EAAMgB,UAAU4D,KAC7B5E,EAAMkI,eAAiBlI,EAAMgB,UAAUkH,eACvClI,EAAMgB,UAAYhB,EAAMgB,UAAUA,UACpC,CAEA,SAAS2O,EAAY3P,EAAO8Q,GAC1B,IAAI5M,EACJ,GAAI6M,EAAO/Q,IAAUA,EAAMqP,KAAM,CAC/B,IAAMzK,EAAO5E,EAAMqP,KAAKrP,EAAM4E,MAC9B,GAAIA,EAAKwL,UAAW,CAClB,IAAMA,EAAYxL,EAAKwL,UAEvB,GADApQ,EAAMkI,gBAAkBlI,EAAMkI,gBACzBlI,EAAMkI,gBAAkBkI,EAAUC,OACrC,MAEJ,CACA,GAAIS,EACF,MAEJ,CAGA,IAFA9Q,EAAMkI,gBAAiB,EACvBlI,EAAM4E,OACC5E,EAAMqP,QAAU5Q,MAAM+H,QAAQxG,EAAMqP,OAASrP,EAAM4E,KAAO5E,EAAMqP,KAAKnS,SAC1EuS,EAAQzP,GACJA,EAAMqP,OACJ0B,EAAO/Q,IACiB,QAArBkE,EAAKlE,EAAMqP,YAAyB,IAAPnL,OAAgB,EAASA,EAAGlE,EAAM4E,MAAMwL,aACxEpQ,EAAMkI,gBAAkBlI,EAAMkI,iBAGhClI,EAAMkI,gBAAiB,EACvBlI,EAAM4E,QAId,CAEA,SAASmM,EAAO/Q,GACd,IAAM4E,EAAOnG,MAAM+H,QAAQxG,EAAMqP,OAA2C,kBAA3BrP,EAAMqP,KAAKrP,EAAM4E,OAAsB5E,EAAMqP,KAAKrP,EAAM4E,MACzG,OAAOA,GAAQA,EAAKmM,MACtB,CAEA,SAASP,EAAaxQ,GACpB,KAAOA,EAAMqP,QAAU5Q,MAAM+H,QAAQxG,EAAMqP,QAASrP,EAAMqP,KAAKrP,EAAM4E,MAAMyL,SACzEZ,EAAQzP,GAENA,EAAMqP,MACRM,EAAY3P,GAAO,EAEvB,CAEA,SAAS+P,EAAIjB,EAAUvC,GAErB,IADA,IAAMyE,EAAQ7U,OAAOiF,KAAK0N,GACjB7N,EAAI,EAAGA,EAAI+P,EAAM9T,OAAQ+D,IAAK,CACrC,IAAMrD,EAAQ2O,EAAO3O,MAAMkR,EAASkC,EAAM/P,KAC1C,GAAIrD,GAASA,aAAiBa,MAC5B,MAAO,CAAEwB,KAAM+Q,EAAM/P,GAAI1E,MAAOqB,EAAM,GAE1C,CACF,CApEAvB,EAAOiT,EAAU,YAajBjT,EAAOoT,EAAS,WAgChBpT,EAAOsT,EAAa,eAKpBtT,EAAO0U,EAAQ,UASf1U,EAAOmU,EAAc,gBAUrBnU,EAAO0T,EAAK,M","sources":["../node_modules/@graphiql/react/dist/Range.es.js","../node_modules/@graphiql/react/dist/hint.es.js","../node_modules/@graphiql/react/dist/onlineParser.es.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nclass CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n    this.getCurrentPosition = () => this._pos;\n    this.eol = () => this._sourceText.length === this._pos;\n    this.sol = () => this._pos === 0;\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n      this._pos++;\n      return char;\n    };\n    this.eat = (pattern) => {\n      const isMatched = this._testNextCharacter(pattern);\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n      return void 0;\n    };\n    this.eatWhile = (match) => {\n      let isMatched = this._testNextCharacter(match);\n      let didEat = false;\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match);\n        didEat = true;\n      }\n      return didEat;\n    };\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n    this.skipTo = (position) => {\n      this._pos = position;\n    };\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token = null;\n      let match = null;\n      if (typeof pattern === \"string\") {\n        const regex = new RegExp(pattern, caseFold ? \"i\" : \"g\");\n        match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = this._sourceText.slice(this._pos).match(pattern);\n        token = match === null || match === void 0 ? void 0 : match[0];\n      }\n      if (match != null) {\n        if (typeof pattern === \"string\" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n            if (token && token.length) {\n              this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n      return false;\n    };\n    this.backUp = (num) => {\n      this._pos -= num;\n    };\n    this.column = () => this._pos;\n    this.indentation = () => {\n      const match = this._sourceText.match(/\\s*/);\n      let indent = 0;\n      if (match && match.length !== 0) {\n        const whiteSpaces = match[0];\n        let pos = 0;\n        while (whiteSpaces.length > pos) {\n          if (whiteSpaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n      return indent;\n    };\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n    let isMatched = false;\n    if (typeof pattern === \"string\") {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  }\n}\n__name(CharacterStream, \"CharacterStream\");\nclass Range {\n  constructor(start, end) {\n    this.containsPosition = (position) => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n    this.start = start;\n    this.end = end;\n  }\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n}\n__name(Range, \"Range\");\nclass Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;\n    this.line = line;\n    this.character = character;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharacter(character) {\n    this.character = character;\n  }\n}\n__name(Position, \"Position\");\nexport { CharacterStream as C, Position as P, Range as R };\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport \"./show-hint.es.js\";\nimport { isCompositeType, getNamedType, TypeNameMetaFieldDef as TypeNameMetaFieldDef$1, SchemaMetaFieldDef as SchemaMetaFieldDef$1, TypeMetaFieldDef as TypeMetaFieldDef$1, GraphQLEnumType, GraphQLBoolean, isInterfaceType, isAbstractType, assertAbstractType, doTypesOverlap, isInputType, DirectiveLocation, visit, parse, isListType, isNonNullType, GraphQLInterfaceType, GraphQLObjectType, Kind, GraphQLInputObjectType, getNullableType, GraphQLList } from \"graphql\";\nimport { R as RuleKinds, C as CompletionItemKind, I as InsertTextFormat } from \"./index.es.js\";\nimport { C as CharacterStream, P as Position } from \"./Range.es.js\";\nimport { o as onlineParser } from \"./onlineParser.es.js\";\nimport { S as SchemaMetaFieldDef, T as TypeMetaFieldDef, a as TypeNameMetaFieldDef } from \"./introspection.es.js\";\nimport \"react\";\nimport \"react-dom\";\nfunction getDefinitionState(tokenState) {\n  let definitionState;\n  forEachState(tokenState, (state) => {\n    switch (state.kind) {\n      case \"Query\":\n      case \"ShortQuery\":\n      case \"Mutation\":\n      case \"Subscription\":\n      case \"FragmentDefinition\":\n        definitionState = state;\n        break;\n    }\n  });\n  return definitionState;\n}\n__name(getDefinitionState, \"getDefinitionState\");\nfunction getFieldDef(schema, type, fieldName) {\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type) {\n    return SchemaMetaFieldDef;\n  }\n  if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type) {\n    return TypeMetaFieldDef;\n  }\n  if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type)) {\n    return TypeNameMetaFieldDef;\n  }\n  if (\"getFields\" in type) {\n    return type.getFields()[fieldName];\n  }\n  return null;\n}\n__name(getFieldDef, \"getFieldDef\");\nfunction forEachState(stack, fn) {\n  const reverseStateStack = [];\n  let state = stack;\n  while (state === null || state === void 0 ? void 0 : state.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (let i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\n__name(forEachState, \"forEachState\");\nfunction objectValues(object) {\n  const keys = Object.keys(object);\n  const len = keys.length;\n  const values = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    values[i] = object[keys[i]];\n  }\n  return values;\n}\n__name(objectValues, \"objectValues\");\nfunction hintList(token, list) {\n  return filterAndSortList(list, normalizeText(token.string));\n}\n__name(hintList, \"hintList\");\nfunction filterAndSortList(list, text) {\n  if (!text) {\n    return filterNonEmpty(list, (entry) => !entry.isDeprecated);\n  }\n  const byProximity = list.map((entry) => ({\n    proximity: getProximity(normalizeText(entry.label), text),\n    entry\n  }));\n  return filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length).map((pair) => pair.entry);\n}\n__name(filterAndSortList, \"filterAndSortList\");\nfunction filterNonEmpty(array, predicate) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n__name(filterNonEmpty, \"filterNonEmpty\");\nfunction normalizeText(text) {\n  return text.toLowerCase().replace(/\\W/g, \"\");\n}\n__name(normalizeText, \"normalizeText\");\nfunction getProximity(suggestion, text) {\n  let proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    proximity -= suggestion.length - text.length - 1;\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\n__name(getProximity, \"getProximity\");\nfunction lexicalDistance(a, b) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n  return d[aLength][bLength];\n}\n__name(lexicalDistance, \"lexicalDistance\");\nconst SuggestionCommand = {\n  command: \"editor.action.triggerSuggest\",\n  title: \"Suggestions\"\n};\nconst collectFragmentDefs = /* @__PURE__ */ __name((op) => {\n  const externalFragments = [];\n  if (op) {\n    try {\n      visit(parse(op), {\n        FragmentDefinition(def) {\n          externalFragments.push(def);\n        }\n      });\n    } catch (_a) {\n      return [];\n    }\n  }\n  return externalFragments;\n}, \"collectFragmentDefs\");\nfunction getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {\n  var _a;\n  const opts = Object.assign(Object.assign({}, options), { schema });\n  const token = contextToken || getTokenAtPosition(queryText, cursor);\n  const state = token.state.kind === \"Invalid\" ? token.state.prevState : token.state;\n  if (!state) {\n    return [];\n  }\n  const kind = state.kind;\n  const step = state.step;\n  const typeInfo = getTypeInfo(schema, token.state);\n  if (kind === RuleKinds.DOCUMENT) {\n    return hintList(token, [\n      { label: \"query\", kind: CompletionItemKind.Function },\n      { label: \"mutation\", kind: CompletionItemKind.Function },\n      { label: \"subscription\", kind: CompletionItemKind.Function },\n      { label: \"fragment\", kind: CompletionItemKind.Function },\n      { label: \"{\", kind: CompletionItemKind.Constructor }\n    ]);\n  }\n  if (kind === RuleKinds.IMPLEMENTS || kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n    return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);\n  }\n  if (kind === RuleKinds.SELECTION_SET || kind === RuleKinds.FIELD || kind === RuleKinds.ALIASED_FIELD) {\n    return getSuggestionsForFieldNames(token, typeInfo, opts);\n  }\n  if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT && step === 0) {\n    const argDefs = typeInfo.argDefs;\n    if (argDefs) {\n      return hintList(token, argDefs.map((argDef) => {\n        var _a2;\n        return {\n          label: argDef.name,\n          insertText: argDef.name + \": \",\n          command: SuggestionCommand,\n          detail: String(argDef.type),\n          documentation: (_a2 = argDef.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n          kind: CompletionItemKind.Variable,\n          type: argDef.type\n        };\n      }));\n    }\n  }\n  if (kind === RuleKinds.OBJECT_VALUE || kind === RuleKinds.OBJECT_FIELD && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      const objectFields = objectValues(typeInfo.objectFieldDefs);\n      const completionKind = kind === RuleKinds.OBJECT_VALUE ? CompletionItemKind.Value : CompletionItemKind.Field;\n      return hintList(token, objectFields.map((field) => {\n        var _a2;\n        return {\n          label: field.name,\n          detail: String(field.type),\n          documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n          kind: completionKind,\n          type: field.type\n        };\n      }));\n    }\n  }\n  if (kind === RuleKinds.ENUM_VALUE || kind === RuleKinds.LIST_VALUE && step === 1 || kind === RuleKinds.OBJECT_FIELD && step === 2 || kind === RuleKinds.ARGUMENT && step === 2) {\n    return getSuggestionsForInputValues(token, typeInfo, queryText, schema);\n  }\n  if (kind === RuleKinds.VARIABLE && step === 1) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    const variableDefinitions = getVariableCompletions(queryText, schema, token);\n    return hintList(token, variableDefinitions.filter((v) => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));\n  }\n  if (kind === RuleKinds.TYPE_CONDITION && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === RuleKinds.TYPE_CONDITION) {\n    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema);\n  }\n  if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));\n  }\n  if (kind === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === RuleKinds.LIST_TYPE && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === RuleKinds.LIST_TYPE || state.prevState.kind === RuleKinds.NON_NULL_TYPE)) {\n    return getSuggestionsForVariableDefinition(token, schema);\n  }\n  if (kind === RuleKinds.DIRECTIVE) {\n    return getSuggestionsForDirective(token, state, schema);\n  }\n  return [];\n}\n__name(getAutocompleteSuggestions, \"getAutocompleteSuggestions\");\nconst insertSuffix = ` {\n  $1\n}`;\nconst getInsertText = /* @__PURE__ */ __name((field) => {\n  const type = field.type;\n  if (isCompositeType(type)) {\n    return insertSuffix;\n  }\n  if (isListType(type) && isCompositeType(type.ofType)) {\n    return insertSuffix;\n  }\n  if (isNonNullType(type)) {\n    if (isCompositeType(type.ofType)) {\n      return insertSuffix;\n    }\n    if (isListType(type.ofType) && isCompositeType(type.ofType.ofType)) {\n      return insertSuffix;\n    }\n  }\n  return null;\n}, \"getInsertText\");\nfunction getSuggestionsForFieldNames(token, typeInfo, options) {\n  var _a;\n  if (typeInfo.parentType) {\n    const parentType = typeInfo.parentType;\n    let fields = [];\n    if (\"getFields\" in parentType) {\n      fields = objectValues(parentType.getFields());\n    }\n    if (isCompositeType(parentType)) {\n      fields.push(TypeNameMetaFieldDef$1);\n    }\n    if (parentType === ((_a = options === null || options === void 0 ? void 0 : options.schema) === null || _a === void 0 ? void 0 : _a.getQueryType())) {\n      fields.push(SchemaMetaFieldDef$1, TypeMetaFieldDef$1);\n    }\n    return hintList(token, fields.map((field, index) => {\n      var _a2;\n      const suggestion = {\n        sortText: String(index) + field.name,\n        label: field.name,\n        detail: String(field.type),\n        documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n        deprecated: Boolean(field.deprecationReason),\n        isDeprecated: Boolean(field.deprecationReason),\n        deprecationReason: field.deprecationReason,\n        kind: CompletionItemKind.Field,\n        type: field.type\n      };\n      const insertText = getInsertText(field);\n      if (insertText) {\n        suggestion.insertText = field.name + insertText;\n        suggestion.insertTextFormat = InsertTextFormat.Snippet;\n        suggestion.command = SuggestionCommand;\n      }\n      return suggestion;\n    }));\n  }\n  return [];\n}\n__name(getSuggestionsForFieldNames, \"getSuggestionsForFieldNames\");\nfunction getSuggestionsForInputValues(token, typeInfo, queryText, schema) {\n  const namedInputType = getNamedType(typeInfo.inputType);\n  const queryVariables = getVariableCompletions(queryText, schema, token).filter((v) => v.detail === namedInputType.name);\n  if (namedInputType instanceof GraphQLEnumType) {\n    const values = namedInputType.getValues();\n    return hintList(token, values.map((value) => {\n      var _a;\n      return {\n        label: value.name,\n        detail: String(namedInputType),\n        documentation: (_a = value.description) !== null && _a !== void 0 ? _a : void 0,\n        deprecated: Boolean(value.deprecationReason),\n        isDeprecated: Boolean(value.deprecationReason),\n        deprecationReason: value.deprecationReason,\n        kind: CompletionItemKind.EnumMember,\n        type: namedInputType\n      };\n    }).concat(queryVariables));\n  } else if (namedInputType === GraphQLBoolean) {\n    return hintList(token, queryVariables.concat([\n      {\n        label: \"true\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not false.\",\n        kind: CompletionItemKind.Variable,\n        type: GraphQLBoolean\n      },\n      {\n        label: \"false\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not true.\",\n        kind: CompletionItemKind.Variable,\n        type: GraphQLBoolean\n      }\n    ]));\n  }\n  return queryVariables;\n}\n__name(getSuggestionsForInputValues, \"getSuggestionsForInputValues\");\nfunction getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {\n  if (tokenState.needsSeparator) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);\n  const schemaInterfaceNames = schemaInterfaces.map(({ name }) => name);\n  const inlineInterfaces = /* @__PURE__ */ new Set();\n  runOnlineParser(documentText, (_, state) => {\n    var _a, _b, _c, _d, _e;\n    if (state.name) {\n      if (state.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {\n        inlineInterfaces.add(state.name);\n      }\n      if (state.kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n        if (typeInfo.interfaceDef) {\n          const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name }) => name === state.name);\n          if (existingType) {\n            return;\n          }\n          const type = schema.getType(state.name);\n          const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();\n          typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [\n            ...interfaceConfig.interfaces,\n            type || new GraphQLInterfaceType({ name: state.name, fields: {} })\n          ] }));\n        } else if (typeInfo.objectTypeDef) {\n          const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name }) => name === state.name);\n          if (existingType) {\n            return;\n          }\n          const type = schema.getType(state.name);\n          const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();\n          typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [\n            ...objectTypeConfig.interfaces,\n            type || new GraphQLInterfaceType({ name: state.name, fields: {} })\n          ] }));\n        }\n      }\n    }\n  });\n  const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;\n  const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];\n  const siblingInterfaceNames = siblingInterfaces.map(({ name }) => name);\n  const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name) => ({ name }))).filter(({ name }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name));\n  return hintList(token, possibleInterfaces.map((type) => {\n    const result = {\n      label: type.name,\n      kind: CompletionItemKind.Interface,\n      type\n    };\n    if (type === null || type === void 0 ? void 0 : type.description) {\n      result.documentation = type.description;\n    }\n    return result;\n  }));\n}\n__name(getSuggestionsForImplements, \"getSuggestionsForImplements\");\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n  let possibleTypes;\n  if (typeInfo.parentType) {\n    if (isAbstractType(typeInfo.parentType)) {\n      const abstractType = assertAbstractType(typeInfo.parentType);\n      const possibleObjTypes = schema.getPossibleTypes(abstractType);\n      const possibleIfaceMap = /* @__PURE__ */ Object.create(null);\n      possibleObjTypes.forEach((type) => {\n        type.getInterfaces().forEach((iface) => {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n    } else {\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    const typeMap = schema.getTypeMap();\n    possibleTypes = objectValues(typeMap).filter(isCompositeType);\n  }\n  return hintList(token, possibleTypes.map((type) => {\n    const namedType = getNamedType(type);\n    return {\n      label: String(type),\n      documentation: (namedType === null || namedType === void 0 ? void 0 : namedType.description) || \"\",\n      kind: CompletionItemKind.Field\n    };\n  }));\n}\n__name(getSuggestionsForFragmentTypeConditions, \"getSuggestionsForFragmentTypeConditions\");\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n  if (!queryText) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const defState = getDefinitionState(token.state);\n  const fragments = getFragmentDefinitions(queryText);\n  if (fragmentDefs && fragmentDefs.length > 0) {\n    fragments.push(...fragmentDefs);\n  }\n  const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n  return hintList(token, relevantFrags.map((frag) => ({\n    label: frag.name.value,\n    detail: String(typeMap[frag.typeCondition.name.value]),\n    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n    kind: CompletionItemKind.Field,\n    type: typeMap[frag.typeCondition.name.value]\n  })));\n}\n__name(getSuggestionsForFragmentSpread, \"getSuggestionsForFragmentSpread\");\nconst getParentDefinition = /* @__PURE__ */ __name((state, kind) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n  if (((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === kind) {\n    return state.prevState;\n  }\n  if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {\n    return state.prevState.prevState;\n  }\n  if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {\n    return state.prevState.prevState.prevState;\n  }\n  if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {\n    return state.prevState.prevState.prevState.prevState;\n  }\n}, \"getParentDefinition\");\nfunction getVariableCompletions(queryText, schema, token) {\n  let variableName = null;\n  let variableType;\n  const definitions = /* @__PURE__ */ Object.create({});\n  runOnlineParser(queryText, (_, state) => {\n    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.VARIABLE && state.name) {\n      variableName = state.name;\n    }\n    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.NAMED_TYPE && variableName) {\n      const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);\n      if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {\n        variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);\n      }\n    }\n    if (variableName && variableType) {\n      if (!definitions[variableName]) {\n        definitions[variableName] = {\n          detail: variableType.toString(),\n          insertText: token.string === \"$\" ? variableName : \"$\" + variableName,\n          label: variableName,\n          type: variableType,\n          kind: CompletionItemKind.Variable\n        };\n        variableName = null;\n        variableType = null;\n      }\n    }\n  });\n  return objectValues(definitions);\n}\n__name(getVariableCompletions, \"getVariableCompletions\");\nfunction getFragmentDefinitions(queryText) {\n  const fragmentDefs = [];\n  runOnlineParser(queryText, (_, state) => {\n    if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {\n      fragmentDefs.push({\n        kind: RuleKinds.FRAGMENT_DEFINITION,\n        name: {\n          kind: Kind.NAME,\n          value: state.name\n        },\n        selectionSet: {\n          kind: RuleKinds.SELECTION_SET,\n          selections: []\n        },\n        typeCondition: {\n          kind: RuleKinds.NAMED_TYPE,\n          name: {\n            kind: Kind.NAME,\n            value: state.type\n          }\n        }\n      });\n    }\n  });\n  return fragmentDefs;\n}\n__name(getFragmentDefinitions, \"getFragmentDefinitions\");\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n  const inputTypeMap = schema.getTypeMap();\n  const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n  return hintList(token, inputTypes.map((type) => ({\n    label: type.name,\n    documentation: type.description,\n    kind: CompletionItemKind.Variable\n  })));\n}\n__name(getSuggestionsForVariableDefinition, \"getSuggestionsForVariableDefinition\");\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n  var _a;\n  if ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) {\n    const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));\n    return hintList(token, directives.map((directive) => ({\n      label: directive.name,\n      documentation: directive.description || \"\",\n      kind: CompletionItemKind.Function\n    })));\n  }\n  return [];\n}\n__name(getSuggestionsForDirective, \"getSuggestionsForDirective\");\nfunction getTokenAtPosition(queryText, cursor) {\n  let styleAtCursor = null;\n  let stateAtCursor = null;\n  let stringAtCursor = null;\n  const token = runOnlineParser(queryText, (stream, state, style, index) => {\n    if (index === cursor.line) {\n      if (stream.getCurrentPosition() >= cursor.character) {\n        styleAtCursor = style;\n        stateAtCursor = Object.assign({}, state);\n        stringAtCursor = stream.current();\n        return \"BREAK\";\n      }\n    }\n  });\n  return {\n    start: token.start,\n    end: token.end,\n    string: stringAtCursor || token.string,\n    state: stateAtCursor || token.state,\n    style: styleAtCursor || token.style\n  };\n}\n__name(getTokenAtPosition, \"getTokenAtPosition\");\nfunction runOnlineParser(queryText, callback) {\n  const lines = queryText.split(\"\\n\");\n  const parser = onlineParser();\n  let state = parser.startState();\n  let style = \"\";\n  let stream = new CharacterStream(\"\");\n  for (let i = 0; i < lines.length; i++) {\n    stream = new CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      style = parser.token(stream, state);\n      const code = callback(stream, state, style, i);\n      if (code === \"BREAK\") {\n        break;\n      }\n    }\n    callback(stream, state, style, i);\n    if (!state.kind) {\n      state = parser.startState();\n    }\n  }\n  return {\n    start: stream.getStartOfToken(),\n    end: stream.getCurrentPosition(),\n    string: stream.current(),\n    state,\n    style\n  };\n}\n__name(runOnlineParser, \"runOnlineParser\");\nfunction canUseDirective(state, directive) {\n  var _a;\n  if (!state || !state.kind) {\n    return false;\n  }\n  const kind = state.kind;\n  const locations = directive.locations;\n  switch (kind) {\n    case RuleKinds.QUERY:\n      return locations.indexOf(DirectiveLocation.QUERY) !== -1;\n    case RuleKinds.MUTATION:\n      return locations.indexOf(DirectiveLocation.MUTATION) !== -1;\n    case RuleKinds.SUBSCRIPTION:\n      return locations.indexOf(DirectiveLocation.SUBSCRIPTION) !== -1;\n    case RuleKinds.FIELD:\n    case RuleKinds.ALIASED_FIELD:\n      return locations.indexOf(DirectiveLocation.FIELD) !== -1;\n    case RuleKinds.FRAGMENT_DEFINITION:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_DEFINITION) !== -1;\n    case RuleKinds.FRAGMENT_SPREAD:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_SPREAD) !== -1;\n    case RuleKinds.INLINE_FRAGMENT:\n      return locations.indexOf(DirectiveLocation.INLINE_FRAGMENT) !== -1;\n    case RuleKinds.SCHEMA_DEF:\n      return locations.indexOf(DirectiveLocation.SCHEMA) !== -1;\n    case RuleKinds.SCALAR_DEF:\n      return locations.indexOf(DirectiveLocation.SCALAR) !== -1;\n    case RuleKinds.OBJECT_TYPE_DEF:\n      return locations.indexOf(DirectiveLocation.OBJECT) !== -1;\n    case RuleKinds.FIELD_DEF:\n      return locations.indexOf(DirectiveLocation.FIELD_DEFINITION) !== -1;\n    case RuleKinds.INTERFACE_DEF:\n      return locations.indexOf(DirectiveLocation.INTERFACE) !== -1;\n    case RuleKinds.UNION_DEF:\n      return locations.indexOf(DirectiveLocation.UNION) !== -1;\n    case RuleKinds.ENUM_DEF:\n      return locations.indexOf(DirectiveLocation.ENUM) !== -1;\n    case RuleKinds.ENUM_VALUE:\n      return locations.indexOf(DirectiveLocation.ENUM_VALUE) !== -1;\n    case RuleKinds.INPUT_DEF:\n      return locations.indexOf(DirectiveLocation.INPUT_OBJECT) !== -1;\n    case RuleKinds.INPUT_VALUE_DEF:\n      const prevStateKind = (_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind;\n      switch (prevStateKind) {\n        case RuleKinds.ARGUMENTS_DEF:\n          return locations.indexOf(DirectiveLocation.ARGUMENT_DEFINITION) !== -1;\n        case RuleKinds.INPUT_DEF:\n          return locations.indexOf(DirectiveLocation.INPUT_FIELD_DEFINITION) !== -1;\n      }\n  }\n  return false;\n}\n__name(canUseDirective, \"canUseDirective\");\nfunction getTypeInfo(schema, tokenState) {\n  let argDef;\n  let argDefs;\n  let directiveDef;\n  let enumValue;\n  let fieldDef;\n  let inputType;\n  let objectTypeDef;\n  let objectFieldDefs;\n  let parentType;\n  let type;\n  let interfaceDef;\n  forEachState(tokenState, (state) => {\n    var _a;\n    switch (state.kind) {\n      case RuleKinds.QUERY:\n      case \"ShortQuery\":\n        type = schema.getQueryType();\n        break;\n      case RuleKinds.MUTATION:\n        type = schema.getMutationType();\n        break;\n      case RuleKinds.SUBSCRIPTION:\n        type = schema.getSubscriptionType();\n        break;\n      case RuleKinds.INLINE_FRAGMENT:\n      case RuleKinds.FRAGMENT_DEFINITION:\n        if (state.type) {\n          type = schema.getType(state.type);\n        }\n        break;\n      case RuleKinds.FIELD:\n      case RuleKinds.ALIASED_FIELD: {\n        if (!type || !state.name) {\n          fieldDef = null;\n        } else {\n          fieldDef = parentType ? getFieldDef(schema, parentType, state.name) : null;\n          type = fieldDef ? fieldDef.type : null;\n        }\n        break;\n      }\n      case RuleKinds.SELECTION_SET:\n        parentType = getNamedType(type);\n        break;\n      case RuleKinds.DIRECTIVE:\n        directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n      case RuleKinds.INTERFACE_DEF:\n        if (state.name) {\n          objectTypeDef = null;\n          interfaceDef = new GraphQLInterfaceType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.OBJECT_TYPE_DEF:\n        if (state.name) {\n          interfaceDef = null;\n          objectTypeDef = new GraphQLObjectType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.ARGUMENTS: {\n        if (!state.prevState) {\n          argDefs = null;\n        } else {\n          switch (state.prevState.kind) {\n            case RuleKinds.FIELD:\n              argDefs = fieldDef && fieldDef.args;\n              break;\n            case RuleKinds.DIRECTIVE:\n              argDefs = directiveDef && directiveDef.args;\n              break;\n            case RuleKinds.ALIASED_FIELD: {\n              const name = (_a = state.prevState) === null || _a === void 0 ? void 0 : _a.name;\n              if (!name) {\n                argDefs = null;\n                break;\n              }\n              const field = parentType ? getFieldDef(schema, parentType, name) : null;\n              if (!field) {\n                argDefs = null;\n                break;\n              }\n              argDefs = field.args;\n              break;\n            }\n            default:\n              argDefs = null;\n              break;\n          }\n        }\n        break;\n      }\n      case RuleKinds.ARGUMENT:\n        if (argDefs) {\n          for (let i = 0; i < argDefs.length; i++) {\n            if (argDefs[i].name === state.name) {\n              argDef = argDefs[i];\n              break;\n            }\n          }\n        }\n        inputType = argDef === null || argDef === void 0 ? void 0 : argDef.type;\n        break;\n      case RuleKinds.ENUM_VALUE:\n        const enumType = getNamedType(inputType);\n        enumValue = enumType instanceof GraphQLEnumType ? enumType.getValues().find((val) => val.value === state.name) : null;\n        break;\n      case RuleKinds.LIST_VALUE:\n        const nullableType = getNullableType(inputType);\n        inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;\n        break;\n      case RuleKinds.OBJECT_VALUE:\n        const objectType = getNamedType(inputType);\n        objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n      case RuleKinds.OBJECT_FIELD:\n        const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n        inputType = objectField === null || objectField === void 0 ? void 0 : objectField.type;\n        break;\n      case RuleKinds.NAMED_TYPE:\n        if (state.name) {\n          type = schema.getType(state.name);\n        }\n        break;\n    }\n  });\n  return {\n    argDef,\n    argDefs,\n    directiveDef,\n    enumValue,\n    fieldDef,\n    inputType,\n    objectFieldDefs,\n    parentType,\n    type,\n    interfaceDef,\n    objectTypeDef\n  };\n}\n__name(getTypeInfo, \"getTypeInfo\");\nCodeMirror.registerHelper(\"hint\", \"graphql\", (editor, options) => {\n  const schema = options.schema;\n  if (!schema) {\n    return;\n  }\n  const cur = editor.getCursor();\n  const token = editor.getTokenAt(cur);\n  const tokenStart = token.type !== null && /\"|\\w/.test(token.string[0]) ? token.start : token.end;\n  const position = new Position(cur.line, tokenStart);\n  const rawResults = getAutocompleteSuggestions(schema, editor.getValue(), position, token, options.externalFragments);\n  const results = {\n    list: rawResults.map((item) => ({\n      text: item.label,\n      type: item.type,\n      description: item.documentation,\n      isDeprecated: item.isDeprecated,\n      deprecationReason: item.deprecationReason\n    })),\n    from: { line: cur.line, ch: tokenStart },\n    to: { line: cur.line, ch: token.end }\n  };\n  if ((results === null || results === void 0 ? void 0 : results.list) && results.list.length > 0) {\n    results.from = CodeMirror.Pos(results.from.line, results.from.ch);\n    results.to = CodeMirror.Pos(results.to.line, results.to.ch);\n    CodeMirror.signal(editor, \"hasCompletion\", editor, results, token);\n  }\n  return results;\n});\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { i as isIgnored, L as LexRules, P as ParseRules } from \"./index.es.js\";\nimport { Kind } from \"graphql\";\nfunction onlineParser(options = {\n  eatWhitespace: (stream) => stream.eatWhile(isIgnored),\n  lexRules: LexRules,\n  parseRules: ParseRules,\n  editorConfig: {}\n}) {\n  return {\n    startState() {\n      const initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeparator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n      return initialState;\n    },\n    token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n__name(onlineParser, \"onlineParser\");\nfunction getToken(stream, state, options) {\n  var _a;\n  if (state.inBlockstring) {\n    if (stream.match(/.*\"\"\"/)) {\n      state.inBlockstring = false;\n      return \"string\";\n    } else {\n      stream.skipToEnd();\n      return \"string\";\n    }\n  }\n  const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n  if (stream.sol()) {\n    const tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n  if (eatWhitespace(stream)) {\n    return \"ws\";\n  }\n  const token = lex(lexRules, stream);\n  if (!token) {\n    const matchedSomething = stream.match(/\\S+/);\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n    pushRule(SpecialParseRules, state, \"Invalid\");\n    return \"invalidchar\";\n  }\n  if (token.kind === \"Comment\") {\n    pushRule(SpecialParseRules, state, \"Comment\");\n    return \"comment\";\n  }\n  const backupState = assign({}, state);\n  if (token.kind === \"Punctuation\") {\n    if (/^[{([]/.test(token.value)) {\n      if (state.indentLevel !== void 0) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token.value)) {\n      const levels = state.levels = (state.levels || []).slice(0, -1);\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n  while (state.rule) {\n    let expected = typeof state.rule === \"function\" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n    if (state.needsSeparator) {\n      expected = expected === null || expected === void 0 ? void 0 : expected.separator;\n    }\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n      if (typeof expected === \"string\") {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n      if ((_a = expected.match) === null || _a === void 0 ? void 0 : _a.call(expected, token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n        if (token.kind === \"Punctuation\") {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n        return expected.style;\n      }\n    }\n    unsuccessful(state);\n  }\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, \"Invalid\");\n  return \"invalidchar\";\n}\n__name(getToken, \"getToken\");\nfunction assign(to, from) {\n  const keys = Object.keys(from);\n  for (let i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n__name(assign, \"assign\");\nconst SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError(\"Unknown rule: \" + ruleKind);\n  }\n  state.prevState = Object.assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeparator = false;\n}\n__name(pushRule, \"pushRule\");\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeparator = state.prevState.needsSeparator;\n  state.prevState = state.prevState.prevState;\n}\n__name(popRule, \"popRule\");\nfunction advanceRule(state, successful) {\n  var _a;\n  if (isList(state) && state.rule) {\n    const step = state.rule[state.step];\n    if (step.separator) {\n      const separator = step.separator;\n      state.needsSeparator = !state.needsSeparator;\n      if (!state.needsSeparator && separator.ofRule) {\n        return;\n      }\n    }\n    if (successful) {\n      return;\n    }\n  }\n  state.needsSeparator = false;\n  state.step++;\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n    if (state.rule) {\n      if (isList(state)) {\n        if ((_a = state.rule) === null || _a === void 0 ? void 0 : _a[state.step].separator) {\n          state.needsSeparator = !state.needsSeparator;\n        }\n      } else {\n        state.needsSeparator = false;\n        state.step++;\n      }\n    }\n  }\n}\n__name(advanceRule, \"advanceRule\");\nfunction isList(state) {\n  const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== \"string\" && state.rule[state.step];\n  return step && step.isList;\n}\n__name(isList, \"isList\");\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n__name(unsuccessful, \"unsuccessful\");\nfunction lex(lexRules, stream) {\n  const kinds = Object.keys(lexRules);\n  for (let i = 0; i < kinds.length; i++) {\n    const match = stream.match(lexRules[kinds[i]]);\n    if (match && match instanceof Array) {\n      return { kind: kinds[i], value: match[0] };\n    }\n  }\n}\n__name(lex, \"lex\");\nexport { onlineParser as o };\n"],"names":["__defProp","Object","defineProperty","__name","target","value","configurable","CharacterStream","sourceText","this","getStartOfToken","_start","getCurrentPosition","_pos","eol","_sourceText","length","sol","peek","charAt","next","char","eat","pattern","_testNextCharacter","eatWhile","match","isMatched","didEat","eatSpace","skipToEnd","skipTo","position","consume","token","RegExp","test","substr","slice","Array","startsWith","backUp","num","column","indentation","indent","whiteSpaces","pos","charCodeAt","current","character","Range","start","end","containsPosition","line","Position","lessThanOrEqualTo","getDefinitionState","tokenState","definitionState","forEachState","state","kind","getFieldDef","schema","type","fieldName","SchemaMetaFieldDef","getQueryType","TypeMetaFieldDef","TypeNameMetaFieldDef","isCompositeType","getFields","stack","fn","reverseStateStack","push","prevState","i","objectValues","object","keys","len","values","hintList","list","filterAndSortList","normalizeText","string","text","filterNonEmpty","map","entry","proximity","getProximity","label","pair","isDeprecated","sort","a","b","array","predicate","filtered","filter","toLowerCase","replace","suggestion","lexicalDistance","indexOf","j","d","aLength","bLength","cost","Math","min","SuggestionCommand","command","title","collectFragmentDefs","op","externalFragments","visit","parse","FragmentDefinition","def","_a","getAutocompleteSuggestions","queryText","cursor","contextToken","fragmentDefs","options","opts","assign","getTokenAtPosition","step","typeInfo","getTypeInfo","RuleKinds","CompletionItemKind","getSuggestionsForImplements","getSuggestionsForFieldNames","argDefs","argDef","_a2","name","insertText","detail","String","documentation","description","objectFieldDefs","objectFields","completionKind","field","getSuggestionsForInputValues","namedInputType","getNamedType","inputType","getVariableCompletions","v","getSuggestionsForFragmentTypeConditions","getSuggestionsForFragmentSpread","isArray","getSuggestionsForVariableDefinition","getSuggestionsForDirective","insertSuffix","getInsertText","isListType","ofType","isNonNullType","parentType","fields","TypeNameMetaFieldDef$1","SchemaMetaFieldDef$1","TypeMetaFieldDef$1","index","sortText","deprecated","Boolean","deprecationReason","insertTextFormat","InsertTextFormat","queryVariables","GraphQLEnumType","getValues","concat","GraphQLBoolean","documentText","needsSeparator","schemaInterfaces","getTypeMap","isInterfaceType","schemaInterfaceNames","inlineInterfaces","Set","runOnlineParser","_","_b","_c","_d","_e","includes","add","interfaceDef","getInterfaces","find","getType","interfaceConfig","toConfig","GraphQLInterfaceType","interfaces","objectTypeDef","objectTypeConfig","GraphQLObjectType","currentTypeToExtend","siblingInterfaceNames","result","_kind","possibleTypes","isAbstractType","abstractType","assertAbstractType","possibleObjTypes","getPossibleTypes","possibleIfaceMap","create","forEach","iface","namedType","typeMap","defState","fragments","getFragmentDefinitions","frag","typeCondition","doTypesOverlap","getParentDefinition","_f","_g","_h","_j","_k","variableType","variableName","definitions","parentDefinition","toString","Kind","selectionSet","selections","isInputType","getDirectives","directive","canUseDirective","styleAtCursor","stateAtCursor","stringAtCursor","stream","style","callback","lines","split","parser","onlineParser","startState","locations","DirectiveLocation","directiveDef","enumValue","fieldDef","getMutationType","getSubscriptionType","getDirective","args","enumType","val","nullableType","getNullableType","GraphQLList","objectType","GraphQLInputObjectType","objectField","CodeMirror","editor","cur","getCursor","getTokenAt","tokenStart","results","getValue","item","from","ch","to","eatWhitespace","isIgnored","lexRules","LexRules","parseRules","ParseRules","editorConfig","initialState","level","rule","pushRule","getToken","inBlockstring","popRule","needsAdvance","advanceRule","tabSize","indentLevel","floor","lex","SpecialParseRules","backupState","levels","expected","separator","ofRule","call","update","unsuccessful","Invalid","Comment","rules","ruleKind","TypeError","successful","isList","kinds"],"sourceRoot":""}